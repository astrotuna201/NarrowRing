#!/usr/bin/perl -Wall                  
# The first line defines the Perl Interpreter
# Written 2/13/05 by DPH
# Updated 8/7/2017

# lists all files of a subdirectory and runs cj2 on the ones that match
# in "body*.dat". Ignores body0.dat which is assumed to be the central
# body. New files cj2 corrected files are created with the .j2e
# extension.

# use File::HomeDir;  NOT INSTALLED in our PERL
# $libpath=   File::HomeDir->my_home . "/Dropbox/bin/perl";   


$studentpath=    $ENV{"HOME"} . "/bin";              
$libpath=        $ENV{"HOME"} . "/Dropbox/bin/perl";              
$maccj2path=     $ENV{"HOME"} . "/Dropbox/bin/hnbbin/mac";       
$linuxcj2path=   $ENV{"HOME"} . "/Dropbox/bin/hnbbin/linux";   
@INC =(@INC, "$libpath","$maccj2path", "$linuxcj2path", "$studentpath");
require 'lib.pl';

@flags = ();
@patterns=();
@ARGV = &parseARGV(*ARGV,*patterns,*flags);
if ($#ARGV == -1) {&printUSAGE();}
#&printARGV(*ARGV,*patterns,*flags);
#@dirs = (@ARGV, ".");
@dirs = (@ARGV);
print "Checking dirs: @dirs";
@dirs = &getChangedDirs("body1.dat","body1.j2e",@dirs);
$com1 = "cj2";
print "Updating dirs: @dirs";
&doAllDir($com1,@dirs);
print "Updated  dirs: @dirs";
print "  --> All .j2e files are up to date.\n";



# This returns a list of directories (current, and one level down) that need updating
# by cj2  because either 1) no .j2e files exist or 2) .dat files have been updated. 
sub getChangedDirs {
    local($file1,$file2,@indirs) = @_;
    my (@dirs, $i,$com1,$numdirs);
    @dirs=();
    foreach $i (@indirs) {
        if (-d $i) {  # directory exists
            if (-r "$i/$file1") {    # file1 exists, readable
                if (-r "$i/$file2") {    # file2 exists, readable                
                    $age1 = (-M "$i/$file1");
                    $age2 = (-M "$i/$file2");
                    # print"$i: ages=  $age1 $age2\n";
                    if ($age2 > $age1) {push @dirs, $i;} # both files exist, ages need updating
                } else {push @dirs, $i;} # file2 does not exist 

            }  # NO DAT FILES print "WARNING: $i/$file1 does not exist.\n";}
        }   #         print "WARNING: $i is NOT a directory.\n";
    }
    @dirs;
}

# This takes a list of directories as arguments
sub doAllDir {
    local($com1,@dirs) = @_;
#    $numdirs = scalar @dirs;
#    if ($numdirs == 0) {push @dirs, ",";}   # do at least one directory

    foreach $i (@dirs) {
        &doonedirectory($i,$com1);  
    }
}

sub doonedirectory {
    local($dir,$com1) = @_;
    my ($M0,@oblate,@masses,$numfiles,$innermasses,$J2,$Mtotal,$com);
    print ">>>  Working on Directory $dir\n";
    chdir $dir; 
    $M0     = &readM0("body1.dat");
    @oblate = &readJ2("input.hnb");
    @masses = &readmasses("input.hnb");
    $masses[0]=$M0;
#  print "M0 = $M0\n";
 print "J2 J4 J6 = $oblate[1] $oblate[2] $oblate[3]   (conversion uses J2 only)";
 print "masses = @masses";
    $numfiles=0;
    $innermasses=0;
    $J2=$oblate[1]*$oblate[0]*$oblate[0];
    open(FILE, "ls |");
    while (<FILE>) {
        if (/dat/) {
            chop($_);
            if (/(.*body)(\d+)\.dat$/) {     # get first body
                if ($2 > 0)  {                # omit body0.dat 
                    $innermasses += $masses[$2]; # total interior mass
                    $Mtotal = $M0 + $innermasses;
#                    $innerJ2 += 0.5*$masses[$2]; # total interior J2		    
#                    $J2total = $J2 + $innerJ2;   # NEED TO GET SEMIMAJOR AXES ... DPH 11/09/17
#             print "Mtotal = $Mtotal\n";
#             $com = $com1 . " $M0   0   $_ > $1$2.osc \n";
#             $com = $com1 . " $M0  $J2  $_ > $1$2.j2e \n";
                    $com = $com1 . " $Mtotal  $J2  $_ > $1$2.j2e \n";
#             $com = $com1 . " $Mtotal  0  $_ > $1$2.oscM \n";
                    printf "$com";
                    system("$com");                            
                    $numfiles++;  # counter: files per directory
                }
            }
        }
    }
    print "$numfiles files processed in directory $dir\n";
    chdir ".."  || die "cannot change to ..\n";   # needed
}


# Reads the central mass from body1.dat
sub readM0 {
    local($infile) = @_;
    my ($M0,@words,$line1);
    open(INFILE,"< $infile");
    $line1 = <INFILE>;
    @words = split(" ",$line1);
    if ($words[0] == "462639") {          # HNBODY file with header
        $M0 = $words[3]*$words[5];       # units times central mass        
    } else {
        print "Cannot read $infile - not in HNBody format \n";
    }
    close(INFILE);
    $M0;    
}

# Reads J2 from input.hnb
sub readJ2 {
    local($infile) = @_;
    my (@words,@oblate,$line);
    @oblate=(0,0,0,0);
    open(INFILE,"< $infile");
    while (<INFILE>) {
        /^([^\#]*)\#*(.*)$/;     # clip off everything after comment char.
        $line = $1;
        @words = split(" ",$line);
        if ($line =~ /OblateRad/i) {
            foreach $word (@words) {
                if (&isnumber($word)) {
                    $oblate[0]=$word;
                }
            }
        }        if ($line =~ /OblateJ2/i) {
            foreach $word (@words) {
                if (&isnumber($word)) {
                    $oblate[1]=$word;
                }
            }
        }
        if ($line =~ /OblateJ4/i) {
            foreach $word (@words) {
                if (&isnumber($word)) {
                    $oblate[2]=$word;
                }
            }
        }
        if ($line =~ /OblateJ6/i) {
            foreach $word (@words) {
                if (&isnumber($word)) {
                    $oblate[3]=$word;
                }
            }
        }                
    }
    close(INFILE);
    @oblate;    
}

sub readmasses {
    local($infile) = @_;
    my ($column,@masses, $i,$numnums,@numbers,@words);
    open(INFILE,"< $infile");
    $column=-99;
    @masses = (0);
    while (<INFILE>) {
        /^([^\#]*)\#*(.*)$/;    # clip off everything after comment char.
        @words = split(" ",$1);
#        $numwords = scalar @words;    # Get number of words. (one more than $#words
        if ($1 =~ /InputO/i) {          # GET column where masses are given
            for ($i=0;$i<=$#words; $i++) {
                if ($words[$i] =~/^Ma/i) {$column=$i-1;}
            }
#            print "column = $column\n";          
        }
        $numnums=0; @numbers=();
#        print "words = @words\n";
#        print "numwords = $numwords\n";        
        for ($i=0;$i<=$#words; $i++) {  # GET the masses
            if (&isnumber($words[$i])) {
                $numnums++;
                push @numbers, $words[$i];    # 
            }
        }
        if ($numnums > 4) {  # if more than 4 numbers on a row ... (2D IC)
            push @masses, $numbers[$column]; 
        }
    }
    close(INFILE);
    @masses;
}


sub isnumber {
    local($number) = @_;

    if ($number =~ /^-?\d*\.?\d+e?-?\d*$/) {return 1;}
    return 0;
}



sub printUSAGE {
    local($program,$USAGE);
    $program=$0;

    if ($program =~ /\/([^\/\s]+)$/) {$program=$1;}  # \ followed by not slashes.
    $USAGE = <<"end_of_input";

    Program $program takes one or more directories as arguments and
    runs the cj2 command on all of the files in those directories that
    match "body*.dat" (except it ignores body0.dat). The body files
    are output from hnbody/hndrag and must be in Cartesian
    coordinates. Files "body*.j2e" are created and filled with
    J2-corrected orbital elements using, for each satellite, the total
    interior mass (planet + interior satellites). Existing "body*.j2e"
    files are replaced only if more recent "body*.dat" files are present.
    Examples: 
        $program .
        $program r1 r2 r3 r4 r5
        $program r?

end_of_input
    print $USAGE;
    exit();
}


